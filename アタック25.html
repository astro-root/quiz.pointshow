<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>アタック25</title>
<style>
:root{
  --bg:#040405; --panel:#0d1113; --card:#0a0b0d; --muted:#99a2a8;
  --p1:#ff4d4f; --p2:#3aa0ff; --p3:#fafafa; --p4:#38d98a;
  --cand-opacity:0.30;
  --cell-size:120px; --gap:12px;
}
html,body{height:100%;margin:0;background:var(--bg);color:#fff;font-family:system-ui,"Hiragino Kaku Gothic ProN","メイリオ",sans-serif}
.wrap{max-width:1280px;margin:18px auto;padding:14px;display:grid;grid-template-columns:1fr 380px;gap:16px;align-items:start}
header{grid-column:1/-1;display:flex;justify-content:space-between;align-items:center}
h1{font-size:24px;margin:0;font-weight:800}
.flag{padding:6px 10px;border-radius:999px;background:rgba(255,255,255,0.02);font-size:13px;color:var(--muted)}

.boardCard{background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));padding:12px;border-radius:12px;display:flex;flex-direction:column;justify-content:space-between;align-items:stretch}

.board{display:grid;grid-template-columns:repeat(5, var(--cell-size));grid-auto-rows: var(--cell-size);gap:var(--gap);justify-content:center;padding:8px;background:var(--panel);border-radius:10px}

.cell{width:var(--cell-size);height:var(--cell-size);border-radius:12px;display:flex;align-items:center;justify-content:center;font-weight:900;font-size:45px;color:#ffffff;border:2px solid rgba(255,255,255,0.4);position:relative;cursor:pointer;user-select:none;overflow:hidden;transition:background-color 200ms, transform 140ms, box-shadow 140ms;}
.cell.empty{background:linear-gradient(180deg,#0d0f11,#0b0c0e);color:var(--muted);border:1px solid rgba(255,255,255,0.03)}
.cell.p1{background:linear-gradient(180deg,#ff8b8c,#ff4d4f);color:#fff;border:2px solid rgba(255,77,79,0.22)}
.cell.p2{background:linear-gradient(180deg,#97d3ff,#3aa0ff);color:#001a2b;border:2px solid rgba(58,160,255,0.22)}
.cell.p3{background:linear-gradient(180deg,#ffffff,#f0f0f0);color:#0b0b0b;border:2px solid rgba(255,255,255,0.06)}
.cell.p4{background:linear-gradient(180deg,#a5f5c8,#38d98a);color:#01210a;border:2px solid rgba(75,224,138,0.2)}
.cell .num{position:relative;z-index:2}

.ownerBadge{position:absolute;left:10px;top:10px;padding:6px;border-radius:6px;font-weight:800;font-size:14px;z-index:4;color:#000;background:rgba(255,255,255,0.9)}
.ownerBadge.p1{background:var(--p1);color:#fff}
.ownerBadge.p2{background:var(--p2);color:#fff}
.ownerBadge.p3{background:var(--p3);color:#000}
.ownerBadge.p4{background:var(--p4);color:#00280f}

.cell.candidate-allowed{outline:5px solid rgba(255,255,255,0.06);transform:translateY(-4px);box-shadow:0 22px 44px rgba(0,0,0,0.6)}
.cell.cand-p1::after,.cell.cand-p2::after,.cell.cand-p3::after,.cell.cand-p4::after{content:"";position:absolute;inset:0;border-radius:12px;z-index:1;opacity:var(--cand-opacity)}
.cell.cand-p1::after{background:var(--p1)}
.cell.cand-p2::after{background:var(--p2)}
.cell.cand-p3::after{background:#ffffff}
.cell.cand-p4::after{background:var(--p4)}
.candMark{position:absolute;right:10px;top:10px;width:26px;height:26px;border-radius:999px;z-index:5;display:flex;align-items:center;justify-content:center;font-size:14px;font-weight:900;color:#fff}
.candMark.p1{background:var(--p1)} .candMark.p2{background:var(--p2)} .candMark.p3{background:#000;color:#fff} .candMark.p4{background:var(--p4)}

.flipping{animation:flipAnim 350ms ease-in-out;}
@keyframes flipAnim{
  0% { transform: rotateY(0deg) scale(1); filter:brightness(1); }
  50% { transform: rotateY(90deg) scale(1.02); filter:brightness(0.5); }
  100% { transform: rotateY(0deg) scale(1); filter:brightness(1); }
}

.side{display:flex;flex-direction:column;gap:12px;align-self:stretch;justify-content:space-between}
.playerCard{background:var(--card);padding:8px;border-radius:10px;border:1px solid rgba(255,255,255,0.04);display:flex;flex-direction:column;gap:6px}
.playerTop{display:flex;justify-content:space-between;align-items:center}
.playerInput{background:transparent;border:1px dashed rgba(255,255,255,0.04);color:#fff;padding:6px;border-radius:8px;font-size:28px;width:160px}
.scoreBig{font-size:36px;font-weight:900}
.metaSmall{color:var(--muted);font-size:13px}

.playerStats{display:flex;justify-content:space-between;gap:12px;align-items:center;margin-top:4px}
.playerStats .stat{display:flex;flex-direction:column;align-items:flex-start}
.playerStats .stat .label{font-size:13px;color:var(--muted);font-weight:700}
.playerStats .stat .value{font-size:18px;font-weight:900;color:#ffffff;margin-top:4px}

.boardControls{display:flex;justify-content:flex-end;gap:12px;align-items:center;margin-top:8px}

.btns{display:flex;gap:8px}
button{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px 12px;border-radius:10px;color:#fff;cursor:pointer;font-weight:700}
button.primary{background:linear-gradient(90deg,#2563eb,#3b82f6);border:none}
.undobtn{padding:10px 14px;border-radius:10px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.04)}
.note{color:var(--muted);font-size:13px;margin-top:6px}
.sideSpacer{flex:1}
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>アタック25</h1>
      <div style="display:flex;gap:8px;align-items:center">
        <div class="flag" id="remaining">残り: 25</div>
        <div class="flag" id="attackFlag">アタック: OFF</div>
      </div>
    </header>

    <div class="boardCard">
      <div id="board" class="board" aria-label="Attack25"></div>

      <div class="boardControls">
        <button onclick="resetBoard()">リセット</button>
        <button class="undobtn" id="undoBtn" onclick="undo()">戻る</button>
      </div>
    </div>

    <aside class="side">
      <div>
        <div class="playerCard" style="border-left:6px solid rgba(255,77,79,0.22)">
          <div class="playerTop">
            <input id="playerName1" class="playerInput" value="P1">
            <div style="text-align:right"><div class="metaSmall">獲得マス</div><div class="scoreBig" id="score1">0</div></div>
          </div>
          <div class="playerStats">
            <div class="stat"><div class="label">誤答</div><div class="value" id="wrong1">0</div></div>
            <div class="stat"><div class="label">Skip</div><div class="value" id="skip1">0</div></div>
          </div>
          <div class="btns"><button onclick="selectPlayer(1)">正解</button><button onclick="markWrong(1)">誤答</button><button onclick="skipReduce(1)">スルー</button></div>
        </div>

        <div class="playerCard" style="border-left:6px solid rgba(58,160,255,0.22);margin-top:12px">
          <div class="playerTop">
            <input id="playerName2" class="playerInput" value="P2">
            <div style="text-align:right"><div class="metaSmall">獲得マス</div><div class="scoreBig" id="score2">0</div></div>
          </div>
          <div class="playerStats">
            <div class="stat"><div class="label">誤答</div><div class="value" id="wrong2">0</div></div>
            <div class="stat"><div class="label">Skip</div><div class="value" id="skip2">0</div></div>
          </div>
          <div class="btns"><button onclick="selectPlayer(2)">正解</button><button onclick="markWrong(2)">誤答</button><button onclick="skipReduce(2)">スルー</button></div>
        </div>

        <div class="playerCard" style="border-left:6px solid rgba(255,255,255,0.06);margin-top:12px">
          <div class="playerTop">
            <input id="playerName3" class="playerInput" value="P3">
            <div style="text-align:right"><div class="metaSmall">獲得マス</div><div class="scoreBig" id="score3">0</div></div>
          </div>
          <div class="playerStats">
            <div class="stat"><div class="label">誤答</div><div class="value" id="wrong3">0</div></div>
            <div class="stat"><div class="label">Skip</div><div class="value" id="skip3">0</div></div>
          </div>
          <div class="btns"><button onclick="selectPlayer(3)">正解</button><button onclick="markWrong(3)">誤答</button><button onclick="skipReduce(3)">スルー</button></div>
        </div>

        <div class="playerCard" style="border-left:6px solid rgba(56,217,138,0.22);margin-top:12px">
          <div class="playerTop">
            <input id="playerName4" class="playerInput" value="P4">
            <div style="text-align:right"><div class="metaSmall">獲得マス</div><div class="scoreBig" id="score4">0</div></div>
          </div>
          <div class="playerStats">
            <div class="stat"><div class="label">誤答</div><div class="value" id="wrong4">0</div></div>
            <div class="stat"><div class="label">Skip</div><div class="value" id="skip4">0</div></div>
          </div>
          <div class="btns"><button onclick="selectPlayer(4)">正解</button><button onclick="markWrong(4)">誤答</button><button onclick="skipReduce(4)">スルー</button></div>
        </div>
      </div>

    </aside>
  </div>

<script>
const OWNER_EMPTY = 0;
let owners = Array(25).fill(0);
let wrongCount = [0,0,0,0,0];
let skipTurns = [0,0,0,0,0];
let currentCorrectPlayer = 0;
let attackActive = false;
let attackOwner = 0;
let attackUsed = false;
let mode = 'normal';
let actionStack = [];
const deltas = [[-1,0],[-1,1],[0,1],[1,1],[1,0],[1,-1],[0,-1],[-1,-1]];
const boardEl = document.getElementById('board');
const remainingEl = document.getElementById('remaining');
const attackFlagEl = document.getElementById('attackFlag');
const undoBtn = document.getElementById('undoBtn');

function idxToRC(i){ return {r: Math.floor(i/5), c: i%5}; }
function rcToIdx(r,c){ return r*5 + c; }
function inBoard(r,c){ return r>=0 && r<5 && c>=0 && c<5; }
function remainingPanels(){ return owners.reduce((s,o)=> s + (o===0?1:0), 0); }
function countOwned(p){ return owners.reduce((s,o)=> s + (o===p?1:0), 0); }
function isBoardEmpty(){ return owners.every(o=>o===0); }
function ownerLabelFor(p){ const name = (document.getElementById('playerName'+p)?.value || ('P'+p)).trim(); return name? name[0].toUpperCase() : ('P'+p); }

function flippableListIfPlaced(panelIdx, player){
  if(owners[panelIdx] !== OWNER_EMPTY) return [];
  const {r,c} = idxToRC(panelIdx);
  let result = [];
  for(const d of deltas){
    let tr = r + d[0], tc = c + d[1];
    const temp = []; let foundOpponent = false;
    while(inBoard(tr,tc)){
      const idx = rcToIdx(tr,tc);
      const owner = owners[idx];
      if(owner === OWNER_EMPTY) break;
      if(owner !== player){ temp.push(idx); foundOpponent = true; }
      else { if(foundOpponent) result = result.concat(temp); break; }
      tr += d[0]; tc += d[1];
    }
  }
  return Array.from(new Set(result));
}

function isAdjacentToAnyOccupied(idx){
  const {r,c} = idxToRC(idx);
  for(const d of deltas){
    const tr = r + d[0], tc = c + d[1];
    if(inBoard(tr,tc) && owners[rcToIdx(tr,tc)] !== OWNER_EMPTY) return true;
  }
  return false;
}

function computeLegal(player){
  const flipList = [];
  for(let i=0;i<25;i++){
    if(owners[i] === OWNER_EMPTY){
      if(flippableListIfPlaced(i,player).length > 0) flipList.push(i);
    }
  }
  if(flipList.length > 0) return flipList;
  const adj = [];
  for(let i=0;i<25;i++){
    if(owners[i] === OWNER_EMPTY && isAdjacentToAnyOccupied(i)) adj.push(i);
  }
  if(adj.length > 0) return adj;
  const all = [];
  for(let i=0;i<25;i++) if(owners[i] === OWNER_EMPTY) all.push(i);
  return all;
}

function saveState(){ return {owners: owners.slice(), wrong: wrongCount.slice(), skip: skipTurns.slice(), currentCorrectPlayer, attackActive, attackOwner, attackUsed, mode}; }
function restoreState(s){
  owners = s.owners.slice();
  wrongCount = s.wrong.slice();
  skipTurns = s.skip.slice();
  currentCorrectPlayer = s.currentCorrectPlayer;
  attackActive = s.attackActive;
  attackOwner = s.attackOwner;
  attackUsed = s.attackUsed;
  mode = s.mode;
  renderBoard();
  updateUI();
  refreshUndo();
}
function pushState(){ actionStack.push(saveState()); if(actionStack.length > 400) actionStack.shift(); refreshUndo(); }
function refreshUndo(){ undoBtn.style.opacity = actionStack.length? '1':'0.4'; undoBtn.style.pointerEvents = actionStack.length? 'auto':'none'; }
function undo(){ if(actionStack.length === 0) return; const prev = actionStack.pop(); restoreState(prev); }

function renderBoard(){
  boardEl.innerHTML = '';
  for(let i=0;i<25;i++){
    const div = document.createElement('div'); div.className = 'cell';
    const o = owners[i];
    if(o === 0) div.classList.add('empty'); else div.classList.add('p'+o);
    div.innerHTML = `<div class="num">${i+1}</div>`;
    div.dataset.idx = i; div.onclick = onCellClick;
    if(o !== 0){
      const badge = document.createElement('div'); badge.className = 'ownerBadge p'+o; badge.textContent = ownerLabelFor(o);
      div.appendChild(badge);
    }
    boardEl.appendChild(div);
  }
  highlightCandidates();
}

function highlightCandidates(){
  const cells = boardEl.querySelectorAll('.cell');
  cells.forEach(c => {
    c.classList.remove('candidate-allowed','cand-p1','cand-p2','cand-p3','cand-p4');
    const m = c.querySelector('.candMark'); if(m) m.remove();
  });
  if(mode === 'choosePanel' && currentCorrectPlayer){
    const legal = computeLegal(currentCorrectPlayer);
    legal.forEach(idx => {
      const el = boardEl.querySelector(`[data-idx="${idx}"]`);
      if(el){
        el.classList.add('candidate-allowed','cand-p'+currentCorrectPlayer);
        const mark = document.createElement('div'); mark.className = 'candMark p'+currentCorrectPlayer; mark.textContent = '✓';
        el.appendChild(mark);
      }
    });
  }
  if(mode === 'attackDelete' && attackOwner){
    for(let i=0;i<25;i++) if(owners[i] !== OWNER_EMPTY){
      const el = boardEl.querySelector(`[data-idx="${i}"]`);
      if(el){
        el.classList.add('candidate-allowed','cand-p'+attackOwner);
        const mark = document.createElement('div'); mark.className = 'candMark p'+attackOwner; mark.textContent = '✖';
        el.appendChild(mark);
      }
    }
  }
}

function refreshAttackActiveFlag(){
  const rem = remainingPanels();
  if(rem === 0){
    attackActive = false;
    mode = 'normal';
    attackOwner = 0;
  }
}

function applyPlaceWithFlip(panelIdx, player){
  return new Promise(resolve => {
    const flips = flippableListIfPlaced(panelIdx, player);
    owners[panelIdx] = player;
    renderBoard();
    const flipEls = flips.map(i => boardEl.querySelector(`[data-idx="${i}"]`)).filter(Boolean);
    flipEls.forEach(el => el.classList.add('flipping'));
    setTimeout(() => {
      for(const i of flips) owners[i] = player;
      renderBoard();

      const rem = remainingPanels();
      refreshAttackActiveFlag();

      if(rem === 5 && !attackUsed){
        attackUsed = true;
        attackActive = true;
        attackOwner = player;
        mode = 'attackDelete';
        renderBoard();
        updateUI();
        alert(`${ownerLabelFor(attackOwner)} のアタックチャンス！パネル1枚選んでください。`);
      } else {
        if(rem === 0){
          attackActive = false;
          mode = 'normal';
        } else {
        }
      }
      resolve();
    }, 300);
  });
}

function decrementSkipsExcept(actingPlayer){ for(let p=1;p<=4;p++){ if(p === actingPlayer) continue; if(skipTurns[p] > 0) skipTurns[p]--; } }

async function selectPlayer(player){
  if(skipTurns[player] > 0){ alert('Skip中のため操作できません'); return; }
  pushState();
  currentCorrectPlayer = player;

  if(isBoardEmpty()){
    await applyPlaceWithFlip(12, player);
    decrementSkipsExcept(player);
    currentCorrectPlayer = 0; renderBoard(); updateUI(); return;
  }

  const legal = computeLegal(player);
  if(legal.length === 0){ alert('置ける場所がありません（パス）'); currentCorrectPlayer = 0; mode = 'normal'; return; }

  if(legal.length === 1){
    await applyPlaceWithFlip(legal[0], player);
    decrementSkipsExcept(player);
    currentCorrectPlayer = 0; renderBoard(); updateUI(); return;
  }

  mode = 'choosePanel'; renderBoard(); updateUI();
}

function markWrong(player){
  pushState();
  wrongCount[player] = (wrongCount[player] || 0) + 1;
  skipTurns[player] = wrongCount[player];
  decrementSkipsExcept(player);
  renderBoard(); updateUI();
}

async function doAttackDeleteAt(idx){
  if(owners[idx] === OWNER_EMPTY){ alert('空きパネルは消せません'); return; }
  if(!attackOwner || attackOwner === 0){ alert('交換対象のプレイヤーが未設定です'); return; }
  pushState();
  owners[idx] = OWNER_EMPTY;
  renderBoard();
  const el = boardEl.querySelector(`[data-idx="${idx}"]`);
  if(el){ el.classList.add('flipping'); setTimeout(()=> el.classList.remove('flipping'), 360); }
  attackActive = false;
  attackOwner = 0;
  mode = 'normal';
  updateUI();
}

async function onCellClick(e){
  const idx = parseInt(e.currentTarget.dataset.idx, 10);
  if(mode === 'choosePanel'){
    const player = currentCorrectPlayer; if(!player){ alert('正解者が未設定です'); return; }
    const legal = computeLegal(player);
    if(!legal.includes(idx)){ alert('そのマスは現在選べません'); return; }
    pushState();
    await applyPlaceWithFlip(idx, player);
    decrementSkipsExcept(player);
    currentCorrectPlayer = 0;
    renderBoard(); updateUI();
    return;
  } else if(mode === 'attackDelete'){
    await doAttackDeleteAt(idx);
    return;
  } else {
  }
}

function nextQuestion(){ pushState(); for(let p=1;p<=4;p++) if(skipTurns[p] > 0) skipTurns[p]--; renderBoard(); refreshAttackActiveFlag(); updateUI(); }

function skipReduce(player){
  if(skipTurns[player] > 0){
    pushState();
    skipTurns[player] = Math.max(0, skipTurns[player] - 1);
    renderBoard(); updateUI();
  } else {
    alert('スキップはありません');
  }
}

function updateUI(){
  refreshAttackActiveFlag();
  remainingEl.textContent = `残り: ${remainingPanels()}`;
  attackFlagEl.textContent = `アタック: ${attackActive? 'ON（発動待ち）':'OFF'}`;
  for(let p=1;p<=4;p++){
    document.getElementById('score'+p).textContent = countOwned(p);
    document.getElementById('wrong'+p).textContent = wrongCount[p] || 0;
    document.getElementById('skip'+p).textContent = skipTurns[p] || 0;
  }
  highlightCandidates(); refreshUndo();
}

function resetBoard(){ if(!confirm('リセットしますか？')) return; pushState(); owners = Array(25).fill(0); wrongCount=[0,0,0,0,0]; skipTurns=[0,0,0,0,0]; currentCorrectPlayer=0; attackActive=false; attackOwner=0; attackUsed=false; mode='normal'; renderBoard(); updateUI(); }

(function init(){ renderBoard(); updateUI(); for(let p=1;p<=4;p++) document.getElementById('playerName'+p).addEventListener('input', renderBoard); })();
</script>
</body>
</html>
