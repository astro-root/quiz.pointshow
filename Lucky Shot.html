<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Lucky Shot</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    :root{
      --bg:#0b0b0b; --panel-top:#003a66; --panel-bottom:#002f51;
      --card-bg: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.04));
      --ok:#33a853; --muted:#9aa7aa; --correct-blue:#3ea6ff; --wrong-red:#ff6b6b;
      --elim-bg:#06283a; --elim-text:#bfc8cc; --rank-bg:#3ea6ff; --rank-color:#01263b;
      --card-shadow:0 8px 20px rgba(0,0,0,0.6); --win-shadow:0 0 20px gold,0 0 40px rgba(255,215,0,0.6);
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;padding:0;font-family:"Hiragino Kaku Gothic ProN","Meiryo",system-ui,sans-serif}
    body{
      background:
        radial-gradient(1200px 600px at 10% 10%, rgba(24,160,176,0.03), transparent 14%),
        linear-gradient(180deg, rgba(255,255,255,0.02), transparent 18%),
        var(--bg);
      color:#eee; padding:18px; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
    }
    .header{ display:flex; align-items:center; gap:12px; padding:12px 16px; border-radius:10px;
      background: linear-gradient(180deg,var(--panel-top),var(--panel-bottom));
      box-shadow:0 6px 18px rgba(0,0,0,0.6), inset 0 -2px 0 rgba(255,255,255,0.03); margin-bottom:12px; }
    .logo{ width:48px;height:48px;border-radius:8px;display:flex;align-items:center;justify-content:center;font-weight:800;font-size:18px;color:#fff;background:linear-gradient(135deg, rgba(255,255,255,0.04), rgba(255,255,255,0.01)); box-shadow:0 6px 12px rgba(0,0,0,0.6) }
    h1{ margin:0; font-size:20px; color:#fff }

    .settings{ display:flex; flex-wrap:wrap; gap:10px; align-items:center; padding:10px 12px; border-radius:10px; margin-bottom:12px;
      background: linear-gradient(180deg, rgba(0,0,0,0.12), rgba(0,0,0,0.04)); box-shadow:0 6px 18px rgba(0,0,0,0.5); }
    .settings label{ display:flex; gap:8px; align-items:center; color:#fff; font-weight:700; padding:8px 10px; border-radius:8px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); border:1px solid rgba(255,255,255,0.02); }
    .settings input[type="number"]{ width:84px; padding:6px 8px; border-radius:6px; border:1px solid rgba(255,255,255,0.04); text-align:center; background:transparent; color:#fff; font-weight:700 }
    .settings button{ padding:8px 12px; border-radius:8px; border:none; cursor:pointer; font-weight:800; font-size:14px; box-shadow:0 6px 12px rgba(0,0,0,0.45); }
    #setupBtn{ background: linear-gradient(180deg,var(--ok),#2b8f44); color:#062f07; }
    #resetAllBtn{ background: linear-gradient(180deg,#d7263d,#b71b2b); color:#fff; }
    #undoGlobalBtn{ background: linear-gradient(180deg,#9e9e9e,#6f6f6f); color:#fff; }

    .players{ display:grid; gap:14px; width:100%; justify-items:stretch; align-items:start; }

    .player{ background: var(--card-bg); padding:12px; border-radius:12px; box-shadow:var(--card-shadow);
      text-align:center; width:100%; display:flex; flex-direction:column; align-items:center; position:relative; border:1px solid rgba(255,255,255,0.03); color:#fff; min-width:0; }

    .name{ writing-mode: vertical-rl; text-orientation: upright; border:none; background:transparent; font-weight:800; font-size:24px; height:250px; width:44px; padding:4px; margin-bottom:8px; text-align:center; color:#fff; }

    .points{ font-size:34px; font-weight:900; color:var(--ok); margin-bottom:8px; min-height:42px; display:flex; align-items:center; justify-content:center; width:100%; position:relative; }
    .points .pts-num{ display:block; }
    .points .rank-badge{ position:absolute; left:8px; top:6px; background:var(--rank-bg); color:var(--rank-color); font-weight:900; padding:4px 8px; border-radius:8px; font-size:12px; }

    /* 正解/誤答欄 — ここに「今回の」ランダム配点を表示します */
    .counts{ display:flex; gap:14px; align-items:center; justify-content:center; width:100%; font-weight:800; margin-bottom:8px }
    .correct-count{ color:var(--correct-blue); min-width:44px; text-align:center; font-size:18px }
    .wrong-count{ color:var(--wrong-red); min-width:44px; text-align:center; font-size:18px }

    .buttons{ display:flex; gap:8px; width:100%; justify-content:center; margin-top:6px }
    .btn{ flex:1; padding:8px 6px; border-radius:8px; border:none; cursor:pointer; font-weight:800; font-size:14px }
    .btn-correct{ background: linear-gradient(180deg,#2fa84f,#1d7b36); color:#042a08 }
    .btn-wrong{ background: linear-gradient(180deg,#e84a4a,#b71b2b); color:#fff }

    .player.eliminated{ background: var(--elim-bg); color: var(--elim-text); box-shadow:none; }
    .player.eliminated .name{ color: var(--elim-text); }
    .player.eliminated .points{ color: var(--elim-text); }
    .player.eliminated .correct-count, .player.eliminated .wrong-count { color: var(--elim-text); opacity:0.95; }
    .player.eliminated .btn{ opacity:0.6; cursor:not-allowed; }

    .player.finished{ box-shadow: var(--win-shadow); opacity:0.98; }

    .pts-num.animate{ animation: pop 0.28s ease; }
    @keyframes pop{ 0%{ transform: scale(1);} 50%{ transform: scale(1.12);} 100%{ transform: scale(1);} }

    @media (max-width:720px){
      .name{ height:88px; width:36px; font-size:16px; }
      .points{ font-size:26px; min-height:36px; }
      .points .rank-badge{ font-size:11px; padding:3px 6px; }
      .counts{ gap:8px; }
    }
  </style>
</head>
<body>
  <div class="header">
    <div class="logo">LS</div>
    <h1>Lucky Shot</h1>
  </div>

  <div class="settings">
    <label>最大ポイント: <input type="number" id="maxPoint" value="10" min="1"></label>
    <label>プレイヤー数: <input type="number" id="playerCount" value="6" min="1" max="20"></label>
    <label>勝ち抜け: <input type="number" id="winScore" value="50" min="1"></label>
    <label>失格: <input type="number" id="loseScore" value="-20"></label>

    <button id="setupBtn">設定</button>
    <button id="resetAllBtn">リセット</button>
    <button id="undoGlobalBtn">戻る</button>
  </div>

  <div class="players" id="playersContainer"></div>

  <div style="text-align:center; margin-top:14px;">
    <button id="nextBtn" style="padding:10px 18px; font-weight:800;">次の問題</button>
  </div>

  <script>
    (function(){
      const maxPointInput = document.getElementById('maxPoint');
      const playerCountInput = document.getElementById('playerCount');
      const winScoreInput = document.getElementById('winScore');
      const loseScoreInput = document.getElementById('loseScore');
      const setupBtn = document.getElementById('setupBtn');
      const resetAllBtn = document.getElementById('resetAllBtn');
      const undoGlobalBtn = document.getElementById('undoGlobalBtn');
      const nextBtn = document.getElementById('nextBtn');
      const container = document.getElementById('playersContainer');

      let players = []; // 各プレイヤー状態
      let historyStack = []; // undo 用スタック（スナップショット）
      let winners = []; // 抜け順 idx 配列

      function buildGrid(count){
        container.style.gridTemplateColumns = `repeat(${count}, 1fr)`;
      }

      function createPlayers(count){
        container.innerHTML = '';
        players = [];
        historyStack = [];
        winners = [];
        buildGrid(count);

        for(let i=0;i<count;i++){
          const card = document.createElement('div'); card.className = 'player';

          const name = document.createElement('input'); name.type='text'; name.placeholder = `プレイヤー${i+1}`; name.className='name';

          const points = document.createElement('div'); points.className='points'; points.innerHTML = `<span class="pts-num">0</span>`;

          // 正解・誤答表示欄（ここに「今回の」ランダム配点を表示します）
          const counts = document.createElement('div'); counts.className='counts';
          counts.innerHTML = `<div class="correct-count">-</div><div class="wrong-count">-</div>`;

          const btnRow = document.createElement('div'); btnRow.className='buttons';
          const btnC = document.createElement('button'); btnC.className='btn btn-correct'; btnC.textContent='正解';
          const btnW = document.createElement('button'); btnW.className='btn btn-wrong'; btnW.textContent='誤答';
          btnRow.append(btnC, btnW);

          card.append(name, points, counts, btnRow);
          container.appendChild(card);

          const state = {
            idx: i, el: card, nameEl: name, pointsEl: points, ptsNumEl: points.querySelector('.pts-num'),
            correctEl: counts.querySelector('.correct-count'), wrongEl: counts.querySelector('.wrong-count'),
            btnC, btnW, points:0, correct:0, wrong:0, currentCorrectPt:0, currentWrongPt:0, rank:0, eliminated:false
          };

          // 正解処理
          btnC.addEventListener('click', ()=>{
            if(state.rank !== 0 || state.eliminated) return;
            // スナップショット保存（undo 用）
            historyStack.push({ type:'snapshot', idx: state.idx, prev: snapshotPlayer(state), winners: winners.slice() });

            state.correct++;
            state.points += state.currentCorrectPt;
            checkWin(state);
            checkLose(state);
            updateAllDisplays(true);
          });

          // 誤答処理
          btnW.addEventListener('click', ()=>{
            if(state.rank !== 0 || state.eliminated) return;
            historyStack.push({ type:'snapshot', idx: state.idx, prev: snapshotPlayer(state), winners: winners.slice() });

            state.wrong++;
            state.points -= state.currentWrongPt;
            checkWin(state);
            checkLose(state);
            updateAllDisplays(true);
          });

          players.push(state);
        }

        updateAllDisplays(false);
      }

      function snapshotPlayer(state){
        return { points: state.points, correct: state.correct, wrong: state.wrong, rank: state.rank, eliminated: state.eliminated };
      }

      function restorePlayerFromSnapshot(state, snap){
        state.points = snap.points; state.correct = snap.correct; state.wrong = snap.wrong; state.rank = snap.rank; state.eliminated = snap.eliminated;
      }

      function checkWin(state){
        const w = Math.max(1, parseInt(winScoreInput.value || 1));
        if(state.rank === 0 && state.points >= w && !state.eliminated){
          winners.push(state.idx);
          state.rank = winners.length;
          // スナップショットは既に保存してあるためここでは追加保存しない
        }
      }

      function checkLose(state){
        const lose = parseInt(loseScoreInput.value || -99999);
        if(!state.eliminated && state.points <= lose){
          state.eliminated = true;
        }
      }

      function updateAllDisplays(animate=true){
        players.forEach(p=>{
          // points 表示
          const ptsNum = p.ptsNumEl;
          // 勝ち抜けは rank バッジを points 内に表示
          const existingBadge = p.pointsEl.querySelector('.rank-badge');
          if(p.rank > 0){
            if(!existingBadge){
              const b = document.createElement('span'); b.className='rank-badge'; b.textContent = ordinalLabel(p.rank); p.pointsEl.appendChild(b);
            } else { existingBadge.textContent = ordinalLabel(p.rank); }
            p.el.classList.add('finished'); p.btnC.disabled = true; p.btnW.disabled = true; p.nameEl.disabled = true;
          } else {
            if(existingBadge) existingBadge.remove();
            p.el.classList.remove('finished');
            if(!p.eliminated){ p.btnC.disabled = false; p.btnW.disabled = false; p.nameEl.disabled = false; }
          }

          // 失格は特別表示
          if(p.eliminated){
            p.el.classList.add('eliminated');
            p.ptsNumEl.textContent = 'Lose';
            p.btnC.disabled = true; p.btnW.disabled = true; p.nameEl.disabled = true;
          } else {
            if(p.rank === 0) p.ptsNumEl.textContent = String(p.points);
          }

          // 「正解数」「誤答数」表示欄には【今回のランダム配点】を表示（ユーザー指定の最大値で生成）
          p.correctEl.textContent = p.currentCorrectPt > 0 ? String(p.currentCorrectPt) : '-';
          p.wrongEl.textContent = p.currentWrongPt > 0 ? String(p.currentWrongPt) : '-';

          // アニメーション
          if(animate && p.ptsNumEl){
            p.ptsNumEl.classList.add('animate'); setTimeout(()=>p.ptsNumEl.classList.remove('animate'), 300);
          }
        });

        undoGlobalBtn.disabled = historyStack.length === 0;
      }

      function ordinalLabel(n){
        if(n % 100 >= 11 && n % 100 <= 13) return n + 'th';
        const last = n % 10;
        if(last === 1) return n + 'st';
        if(last === 2) return n + 'nd';
        if(last === 3) return n + 'rd';
        return n + 'th';
      }

      // 次の問題：各プレイヤーごとに今回の正解／誤答ポイントをランダム生成して counts（正解数・誤答数表示欄）に出す
      function nextQuestion(){
        const maxP = Math.max(1, parseInt(maxPointInput.value || 10));
        players.forEach(p=>{
          p.currentCorrectPt = Math.floor(Math.random() * maxP) + 1;
          p.currentWrongPt = Math.floor(Math.random() * maxP) + 1;
          // 表示は updateAllDisplays で行う
        });
        updateAllDisplays(false);
      }

      // Undo（グローバル）：直近の snapshot を復元（winner 配列も復元）
      function undoGlobal(){
        if(historyStack.length === 0) return;
        const last = historyStack.pop();
        if(!last) return;
        // winners は snapshot に含めているため復元
        const prevWinners = last.winners || [];
        winners = prevWinners.slice();
        // player の rank を winners 配列に合わせて復元
        players.forEach(p => {
          const pos = winners.indexOf(p.idx);
          p.rank = pos === -1 ? 0 : pos + 1;
        });
        // restore specific player's snapshot
        const target = players[last.idx];
        restorePlayerFromSnapshot(target, last.prev);
        updateAllDisplays(true);
      }

      function resetAll(){
        players.forEach(p=>{
          p.points = 0; p.correct = 0; p.wrong = 0; p.rank = 0; p.eliminated = false; p.currentCorrectPt = 0; p.currentWrongPt = 0; p.nameEl.value = '';
        });
        historyStack = []; winners = [];
        updateAllDisplays(false);
      }

      // handlers
      setupBtn.addEventListener('click', ()=>{
        const cnt = Math.max(1, Math.min(20, parseInt(playerCountInput.value || 6)));
        createPlayers(cnt);
      });
      resetAllBtn.addEventListener('click', ()=>{
        const cnt = Math.max(1, Math.min(20, parseInt(playerCountInput.value || 6)));
        createPlayers(cnt);
      });
      nextBtn.addEventListener('click', nextQuestion);
      undoGlobalBtn.addEventListener('click', undoGlobal);

      // live grid adjust on participant count change
      playerCountInput.addEventListener('input', ()=>{
        const cnt = Math.max(1, Math.min(20, parseInt(playerCountInput.value || 6)));
        buildGrid(cnt);
      });

      // initial
      const initialCount = Math.max(1, Math.min(20, parseInt(playerCountInput.value || 6)));
      createPlayers(initialCount);
      nextQuestion();
    })();
  </script>
</body>
</html>
